--------------------------------
title
   Galen Specs Language Guide
--------------------------------
date
   2013-10-20 11:14
--------------------------------
allowComments
   true
--------------------------------
categories
   
================================

bq. *Important!* In the version 2.0 the syntax was changed completely and it is not backwards-compatible. If you don't want to switch to a new version then you can check this "old documentation for v1.6":/docs/reference-v1-galen-spec-language-guide/.
If you do want to switch but already have a lot of specs in the old format you can check this page for quick hints: "Galen Specs Language 2.0 comparison with old version":/docs/specslang-2.0-difference/

* "Comments":#Comments
* "Object definition":#Objectdefinition
* "Multiple objects definition":#Multipleobjectsdefinition
* "Objects corrections":#Objectscorrections
* "Ranges":#Ranges
* "Tagging and Sections":#TaggingandSections
* "Variables":#Variables
* "Special Objects":#SpecialObjects
* "Specs Reference":#SpecsReference
** "Near":#Near
** "Below and Above":#BelowandAbove
** "Left of and Right of":#LeftofandRightof
** "Inside":#Inside
** "Width and Height":#WidthandHeight
** "Aligned":#Aligned
** "Text":#Text
** "CSS Properties":#CSSProperties
** "Centered":#Centered
** "Absent":#Absent
** "Visible":#Visible
** "Contains":#Contains
** "On":#On
** "Component":#Component
** "Count":#Count
** "Color scheme":#Colorscheme
** "Image":#Image
* "Advanced Specs":#AdvancedSpecs
** "Importing":#Importing
** "Multiple objects with same specs":#Multipleobjectswithsamespecs
** "for Loop":#forLoop
** "forEach Loop":#forEachLoop
** "Custom javascript functions in specs":#Customjavascriptfunctionsinspecs
** "if statement":#ifStatement
** "Warning level for specs":#Warninglevelforspecs
** "Custom rules":#CustomRules
** "Notes for specs":#Notesforspecs
* "Galen Specs JS Api":#GalenSpecsJSApi


Galen Specs Language is quite flexible and gives you the opportunity to express exactly how you want your website to behave on different devices. There are two main parts in page specs file: *object definitions* and *object specs*

h1. Comments

All comments should start with '#' symbol in the beginning of a line. If you use '#' symbol somewhere in the middle of text it will be taken as is. That is due to ability to work with CSS locators which might have this symbol in their expression

$$ galen-specs
# This line a comment
# However next line is not a comment
object  css     #container ul li
$$


h1. Object definition

Each Galen spec file normally starts with object definition. It is the place where you give names to page objects and also define the so called *locators* - the way for Galen to find element on test page. The available locators are:

* id _- searches for object by id in DOM_
* css _- uses CSS selectors to find objects_
* xpath _- uses "XPath expressions":http://www.w3schools.com/xpath/_ 

The object definition is defined with *@objects* keyword and all objects are declared below it.
Lets take a look at the following HTML example and try to define these objects in our spec file

$$ html
<body>
    <div id='search-bar'>
        <input type='text' name='search' value=''/>
        <a href='#' class='search-button'>Search</a>
    </div>
</body>
$$

Now lets try out all available locators in Galen spec for the example above

$$ galen-specs
@objects
    search-panel            id      search-bar
    search-panel-input      xpath   //div[@id='search-bar']/input[@type='text']
    search-panel-button     css     #search-bar a
$$


Also you can skip the locator type definition. In that case Galen will consider that the given locator is css selector.

$$ galen-specs
@objects
    search-panel            #search-bar
    search-panel-input      #search-bar input[type='text']
    search-panel-button     #search-bar a
$$

Also you can optimize your locators by nesting objects

$$ galen-specs
@objects
    search-panel   #search-bar
        input      input[type='text']
        button     a
$$

This way Galen will automatically wrap the locators in the scope of the parent object and will create object references with the following names:
* *search-panel*
* *search-panel.input*
* *search-panel.button*



h1. Multiple objects definition

Quite often in HTML we have similar objects which we could fetch with a single locator. This can also be done with Galen. Lets take a look at sample HTML code for menu 

$$ html
<ul id='menu'>
    <li><a href='#'>Home</a></li>
    <li><a href='#'>Blog</a></li>
    <li><a href='#'>Categories</a></li>
    <li><a href='#'>About</a></li>
</ul>
$$

It would be nice to define all these menu items with a single css locator like @#menu li a@. Lets do it in our spec file:

$$ galen-specs
@objects
    menu-item-*     css     #menu li a
$$

As you can see we used asterisk in object name. In this case Galen will find all elements on page and will give them names @menu-item-1@, @menu-item-2@, @menu-item-3@, @menu-item-4@. As you can see it replaces asterisk with a number of on object on page.


h1. Objects corrections

Sometimes it is hard to fetch the real size and position of page element. This happens rarely but when it happens it gives a lot of headache. You can fix this by using so called *corrections*. For instance we have an element on page that is located correctly but its width should be by 50 pixels less then what Galen gets. Lets write down this in our spec file:

$$ galen-specs
@objects
    some-test-object    @(0, 0, -50, 0)   id  some-container
$$

Or lets say we have an object but we want to move its boundary box down by 100 pixels and also to the left by 30 pixels

$$ galen-specs
@objects
    some-test-object    @(-30, +100, 0, 0)   id  some-container
$$

Or maybe we need to extend the height of the element by 200 px

$$ galen-specs
@objects
    some-test-object    @(0, 0, 0, +200)   id  some-container
$$

Sometimes we need to specify the exact value in corrections

$$ galen-specs
@objects
    some-test-object    @(0, 0, 0, =200)   id  some-container
$$

h1. Ranges

The basis for all specs is a so called "range". Range is a format of defining boundaries for any value. With the range you may express that the expected value should be exactly '0', or greater than '0', less then '0' etc.

$$ galen-specs
# Exact range
    width 100px

# The value between range
    width 50 to 200 px

# Greater than
    width > 40 px

# Less than
    width < 40 px

# Approximate
    width ~ 100 px
$$

As you can see all examples of ranges above end with 'px' symbol. This is important for Galen as we define the units in which it should check the values. In case you want to check relative values you can do it by using '%' symbol but then the syntax will be a bit different

$$ galen-specs
# Relative ranges
    width 50 % of screen/width
$$

In the example above we state that the width of some object should take half of the screen. In this case *screen* is a special Galen object which you don't need to define in your specs. It has width and height of browser inner window.
You can also mix in the example of range above with relative checks 

$$ galen-specs
    width ~ 95 % of screen/width
    height > 40 % of screen/height
    width 30 to 100 % of screen/width
$$

You can also use your own objects for relative checks. For any object you can use 'width' and 'height' properties like in example below:

$$ galen-specs
@objects
    main                id      main-container
    menu                css     ul.menu
    comments            css     div.comments

= Main section =
    menu:
        width ~ 100 % of main/width

    comments:
        width 40 % of main/width
        height 90 to 100 % of main/height
$$

Another special Galen object you could use is *viewport*. Similar to *screen* object it takes the browsers client window. It is useful if you want to check some fixed element on screen which sticks to viewport even when you scroll.

$$ galen-specs
    width 100% of viewport/width
$$


h1. Tagging and Sections

Sections are declared with @=@ symbol in the beginning and end of the line. Also in Galen you can have multiple sections within each other. This allows you to structure your test code so that it is easier to read it.

$$ galen-specs
= Header section =
    = Icons and text =
        header.icon:
            inside header 10px top left

        header.caption: 
            text is "Greetings!"

    = User section =
        header.username:
            inside header 10px top right
$$

Quite often you need to declare different specs for different conditions (e.g. various devices like mobile, tablet, desktop etc.). You can specify tags in your spec file so that it is easier to manage your layout testing. You can wrap all your checks inside *@on* statement like this:

$$ galen-specs
= Main section =
    @on mobile
        menu:
            height 300 px

    @on desktop
        menu:
            height 40 px
$$


In case your specs apply to all of the tags you can express that by using @*@ symbol

$$ galen-specs
= Main section = 
    @on *
        menu:
            height 70px

    @on mobile
        login-button:
            width 100px
$$


You can also combine multiple tags using comma-separated tag notation

$$ galen-specs
= Main section =
    @on mobile, desktop
        menu:
            height 300 px
$$


h1. Variables

In case you want to use common values for different specs you can declare variables on page like this:

$$ galen-specs
@set
    commonHeaderMargin    10 to 20px
    contentMargin  ~ 20px

= Header =
    header-icon:
        inside header ${commonHeaderMargin} top left

= Content =
    article-description:
        inside main ${contentMargin} left right
$$


h1. Special Objects

There are several special objects in Galen Framework that you can use in your spec without defining them

h3. viewport

Represents the visible area on the page.

$$ galen-specs
= Main =
    feedback-button:
        inside viewport 0px right
        centered vertically inside viewport
$$


h3. screen

Represents the whole page area inside browser even that which is not visible.  

$$ galen-specs
= Main =
    menu:
        aligned horizontally screen
$$

h3. parent, self

This element can only be referenced inside a "component":#Component spec. @parent@ and @self@ are the same and represent the component element itself


$$ galen-specs
= Component =
    icon:
        inside parent 0px top left

    self:
        image imgs/component.png
$$

h3. global

Reserved for global validations that are not related to a specific objects. For instance it could be used for "count":#Count spec

$$ galen-specs
    global:
        count any menu-item-* is 4
$$


h1. Specs Reference

Galen supports the following specs:

* "near":#Near _- checks that object is located near another object_
* "below":#BelowandAbove _- checks that an element is located below other object_
* "above":#BelowandAbove _- checks that an element is located above other object_
* "left-of and right-of":#LeftofandRightof _- checks that an element is located above other object_
* "inside":#Inside _- checks that object is located inside another object_
* "width":#WidthandHeight _- checks the width of object_
* "height":#WidthandHeight _- checks the height of object_
* "aligned":#Aligned _- checks horizontal or vertical alignment of object with other objects on page_
* "text":#Text _- checks the text that is visible on page_
* "centered":#Centered _- checks that object is centered inside another object_
* "absent":#Absent _- checks that object is either missing on page or is not visible_
* "contains":#Contains _- checks that object visually contains other objects inside it_
* "on":#On _- checks that object is visually located on other object_
* "component":#Component _- runs a subset of specs from another file within the given object context_
* "color-scheme":#Colorscheme _- checks the color distribution in the given object area_

bq. *IMPORTANT!* For each spec Galen always checks that all included elements in a spec are visible on page. Galen tries to act as a real user and if a user doesn't see an object on page then it is not there.

h2. Near

Used to verify that element is located near another element
Take a look at the following example

{@ sketch
    image: spec-near-01.png
}

Now lets try to write a spec for checking that

$$ galen-specs
textfield:
    near button 10px left
$$

Or we can be less strict about the actual range:

$$ galen-specs
textfield:
    near button 5 to 15px left
$$

Now another example for spec *near*

{@ sketch
    image: spec-near-02.png
}

$$ galen-specs
textfield:
    near button 5px top
$$

Or even more interesting case:

{@ sketch
    image: spec-near-03.png
}

$$ galen-specs
textfield:
    near button 5px bottom left
$$

Or this case: 

{@ sketch
    image: spec-near-04.png
}

$$ galen-specs
textfield:
    near button 5px top, 10px left
$$


h2. Below and Above

There is also a way to test if an element is located above or below another element. Actually this could also be done with the previous spec @near@. But it is good to have a more readable test code so Galen introduces the two specs @above@ and @below@

{@ sketch
    image: spec-below.png
}

$$ galen-specs
caption:
    above description 10 to 20 px

description:
    below caption 10 to 20 px
$$


h2. Left of and Right of

In order to increase readability in version 1.6 were added two specs: @left-of@ and @right-of@. These specs check that the object is located near another object from left or right. You could still use spec @near@ for this case but @left-of@ and @right-of@ also would work well in terms of readability.

{@ sketch
    image: spec-near-01.png
}

$$ galen-specs
textfield:
    left-of button 10px

button:
    right-of textfield 10px
$$

h2. Inside

Spec *inside* verifies that an element is visually inside another element. There two ways how you could use this spec:

* *inside* _- checks that element is completely inside_
* *inside partly* _- checks only the ranges provided in spec. Doesn't care if the element is not completely inside_

Lets take a look at the following example on a picture:

{@ sketch
    image: spec-inside-01.png
}

Now what we can write in a spec

$$ galen-specs
button:
    inside container 10 px top left
$$


A little bit more complicated

{@ sketch
    image: spec-inside-02.png
}

$$ galen-specs
button:
    inside container 10px left right, 20px top bottom
$$


But what to do if our button "sticks out" a little bit?

{@ sketch
    image: spec-inside-03.png
}

$$ galen-specs
button:
    inside partly container 10px top left
$$


Or... A bit weird case... But why not?

$$ galen-specs
button:
    inside partly container -10px top left
$$

bq. Try to avoid the example above. For the illustrated case it is advised to use spec *on*


You can also omit the sides definition in the @inside@ spec and just use it like this:

$$ galen-specs
button:
    inside container
$$

That way Galen will only check that the element is completely inside another element. Still it is not a good practice to do so and the advice is - always specify sides to which the element is attached.



h2. Width and Height

Width and height have exactly the same simple syntax

{@ sketch
    image: spec-width-and-height-01.png
}

$$ galen-specs
button:
    width 100 px
    height 25px
$$

Or we can also say that width should not be bigger that 100 pixels

$$ galen-specs
button:
    width < 101 px
$$

Relative width and height specs. Lets check that comments sections is stretched to the width of main container

{@ sketch
    image: spec-width-and-height-02.png
}

$$ galen-specs
comments:
    width 100 % of main/width
$$

Or we can be less strict and do it like this. This way Galen will not fail if comments section is only by few pixels smaller.

$$ galen-specs
comments:
    width 95 to 100 % of main/width
$$


h2. Aligned 

Sometimes you have things which are aligned horizontally or vertically on your website. Quite common examples are menus.
The syntax is the following
* *aligned horizontally all* _- checks that items are aligned horizontally by their top and bottom edges_
* *aligned horizontally top* _- check that items are aligned horizontally by top edge only_
* *aligned horizontally bottom* _- check that items are aligned horizontally by bottom edge only_
* *aligned horizontally centered* _- check that items are aligned horizontally by center_ 
* *aligned vertically all* _- checks that items are aligned vertically by their top and bottom edges_
* *aligned vertically left* _- checks that items are aligned vertically by their left edge_
* *aligned vertically right* _- checks that items are aligned vertically by their right edge_
* *aligned vertically centered* _- checks that items are aligned vertically by center_


Now lets take a look at the following scheme and lets write down the according Galen spec

{@ sketch
    image: spec-horizontally-01.png
}

$$ galen-specs
# By top and bottom edges
menu-item-1:
    aligned horizontally all menu-item-2
$$


And now alignment by only one edge

{@ sketch
    image: spec-horizontally-02.png
}

$$ galen-specs
# By top edge
menu-item-1:
    aligned horizontally top menu-item-2
$$


Vertical alignment by left edge:

{@ sketch
    image: spec-vertically-01.png
}

$$ galen-specs
menu-item-1:
    aligned vertically left menu-item-2
$$

There is also a possibility to define the error rate within which we don't care if objects are not aligned. For instance it could be that one object is by 1px higher than the other one. If we are OK with that we can define it in our spec like this:

$$ galen-specs
menu-item-1:
    aligned horizontally all menu-item-2 1px
$$

In the code above we have defined the 1 pixel error rate so galen will not complain if object are misaligned by only one pixel.


h2. Text 

There are various ways you could verify text of an element on page. Note that the text that is seen by Galen is not same as it is in HTML code. As Galen relies on Selenium - the text will be returned the same way it appears in a real browser (e.g. white space is ignored). At the moment you can verify text with following specs:

* *text is* _- checks that text is exactly as expected_
* *text contains* _-checks element contains expected text_
* *text starts* _- element should start with expected text_
* *text ends* _- element should end with expected text_
* *text matches* _- verifies that text matches "Java Regular Expression":http://docs.oracle.com/javase/tutorial/essential/regex/_

Here are some examples of different text specs. Lets say we would like to test the following page element:

$$ html
<div>Welcome user@example.com to our cool website!</div>
$$

Now lets write down all possible text checks for it

$$ galen-specs
greeting:
    text is "Welcome user@example.com to our cool website!"
    text starts "Welcome"
    text ends "website!"
    text contains "to our cool"
    text matches "Welcome .* to our cool website!"
$$


h3. Text operations

Sometimes you don't want to check the text case sensitive. For this purpose you can rely on special text operations. At the moment only these operations are supported: *lowercase* and *uppercase*.

$$ galen-specs
greeting:
    text lowercase is "welcome user@example.com to our cool website!"
    text uppercase starts "WELCOME"
    text lowercase ends "website!"
    text lowercase contains "to our cool"
    text lowercase matches "welcome .* to our cool website!"
$$


h2. CSS Properties

By analogy of "text spec":#Text the @css@ spec allows you to test the value of a CSS property of a specific element. For instance you can check the @font-size@, @font-family@, @background-color@ or any other CSS property you want. Use it in a same way as @text@ property:

$$ galen-specs
login-button:
    css font-size is "18px"
    css font-family starts "Helvetica"
    css font-family ends "sans-serif"
    css font-family contains "Arial"
    css font-family matches ".*Arial.*"
$$

At the moment text operations lowercase and uppercase are not available in @css@ spec.

bq. *Important!* Galen Framework originally was planned as UI testing tool which is not dependent on CSS and HTML. The use of @css@ specs breaks the original purpose and it was introduced only because of high demand from users. Use this @css@ spec rarely and wisely.



h2. Centered

If you want to check that the element is centered inside another element you can of course use the spec *inside* by defining same range for left and right sides. But there is a problem if it is responsive design. Then there is a special spec called *centered*. It allows to verify that the element is centered inside or on top of another element with user-defined error rate. Lets take a look at the following scheme:

{@ sketch
    image: spec-centered-01.png
}

We could write it down like this:

$$ galen-specs
button:
    centered horizontally inside box
$$

Or if the label is also centered vertically we can include both checks in one line by doing this:

{@ sketch
    image: spec-centered-02.png
}


$$ galen-specs
button:
    centered all inside box
$$

But this will fail if a label is not inside box but "sticks out" of it edges. Lets take this example on picture:

{@ sketch
    image: spec-centered-on.png
}

As we see here it looks like the label is placed on top of a box. In this case we should write it down like this:

$$ galen-specs
label:
    centered horizontally on box
$$


But what to do if the element is not exactly in a center? What if an item is shifted 10px left or right from the center?

{@ sketch
    image: spec-centered-03.png
}

We need the ability to define error rate within which an element should be considered centered. We can specify this in our spec in the following way.

$$ galen-specs
label:
    centered horizontally inside box 10px
$$


h2. Absent

One of the simplest specs in Galen. It doesn't take any parameters. It is used to check that the element is either missing on page _(in HTML code)_ either it is present but not visible _(e.g. style display:none)_

$$ galen-specs
comments:
    absent
$$


h2. Visible

Same idea as spec *absent* but in this case Galen checks that the element is visible

$$ galen-specs
comments:
    visible
$$


h2. Contains

Used to verify that the element contains a list of specified elements. 

$$ galen-specs
comments:
    contains comment-header, comment-send-button, comment-textfield
$$

You can also use asterisk to match all other objects so you write less text. For example lets say we have an object @menu@ and in it there other object like: @menu-item-home@, @menu-item-categories@, @menu-item-about@, @menu-item-contact@. Instead of enumerating all of them in same spec we can write a shorter version:

$$ galen-specs
menu:
    contains menu-item-*
$$

Another case that you might have is when an element is not completely inside. For that you can use spec *contains partly*. Take a look at the following example

$$ galen-specs
box:
    contains partly box-item-1, box-item-2
$$


h2. On

Verifies that the element is moved from another element from specified corner. Visually it could be considered as if one element located on top of another. Take a look at the following example

{@ sketch
    image: spec-on.png
}

$$ galen-specs
user-picture-label:
    on top left edge user-picture 20 px left, 10px bottom
$$

You can also pick a different corner:

$$ galen-specs
user-picture-label:
    on bottom left edge user-picture 20px right, 10 px top
$$


h2. Component

Used for advanced testing in case there are multiple similar complex snippets on page. As an example lets imagine that we have a page where we list user profiles. Every user profile has same layout and we would like to test that somehow.

{@ sketch
    image: spec-component.png
}

For the example above we would need a separate spec file where we can define the specs for a component. Later this file will be used in another page spec. So lets create a component spec named @user-profile.gspec@

$$ galen-specs
@objects 
    user-name       css     .user-name
    user-pic        css     .user-pic
    user-age        css     .user-age

= User section =
    user-pic:
        inside parent 10px top left
        width 50px
        height 50px

    user-name:
        inside parent 10px top
        near user-pic 10px right

    user-age:
        below user-name 5px
        near user-pic 10px
$$

Now we are going to test the user profile using the component spec file we have prepared.

$$ galen-specs
@objects
    user-profile-*  css   .user-profile

= All user profiles =
    user-profile-*:
        component user-profile.gspec
$$

In this case Galen will first fetch all objects *user-profile-1*, *user-profile-2*, *user-profile-3* and then will load a subtest for objects within each user profile scope. This means that you can reuse components within the same page for different object or in general for different pages.



h3. Frame support

In case you have to test a website which has frames and you need to access the elements inside frame you could use @component frame@ spec.

$$ galen-specs
@objects
    banner-frame     css  iframe#banner

= Main section =
    banner-frame:
        component frame banner.gspec
$$


h2. Count

You can validate the amount of objects on page that match some custom expression.

h4. Count all elements on page

$$ galen-specs
= Main =
    global:
        count any menu-item-* is 3
$$

Count spec takes "range":#Ranges argument but without @px@ so you can use it like this

$$ galen-specs
        count any menu-item-* is 4 to 5
$$

Or this

$$ galen-specs
        count any menu-item-* is < 6
$$

h4. Count only visible elements on page

If you want to count only the elements that are visible you can use @visible@ argument instead of @any@

$$ galen-specs
        count visible menu-item-* is 4 to 5
$$

h4. Count only absent elements

If you need to validate the amount of absent elements that you can use it like this:

$$ galen-specs
        count absent menu-item-* is 4 to 5
$$

h2. Color scheme

Used when you need to verify color distribution on object area. Galen takes a picture and then calculates the objects area color spectrum so later you can verify the usage for specific colors. Example:

$$ galen-specs
login-form:
    color-scheme 10% white, 4 to 5 % black, < 30% #f845b7
$$




h2. Image

Galen Framework also allows to perform more advanced check like image comparison. When you need to make sure your buttons or logos stay the same you can compare them by predefined image pixel to pixel. Example:

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, error 12px
$$

The above spec will compare object on the screen pixel to pixel with image @imgs/menu-item-1.png@ and will notify if amount of mismatching pixel is higher than maximum allowed 12 pixels.

You can also change the assertion from absolute pixels values to percentage like this:

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, error 4%
$$

In the generated report you can see which image was expected and also you can find the comparison map

!files/image01.png!

The red pixels on comparison map are the mismatching pixels that are far away from the *tolerance* value. The yellow pixels are in the range of 30 to 80 color difference from tolerance. The green pixels are the closest to the tolerance value. You can play a bit with this spec by changing the tolerance value:

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, error 4%, tolerance 80
$$

The *tolerance* - is the maximum allowed color difference of two compared pixels. By default the tolerance is set to 30. If you increase this parameter - the amount of mismatching pixels will be decreased but than you risk of not having the proper comparison.

h3. Multiple image comparison

Sometimes you might have different images for different browsers and this will break all your tests. Just for this case you can define different image samples in one image spec like this:

$$ galen-specs
header-text:
    image file image-1.png, file image-2.png, file image-3.png, error 20px
$$

This way Galen compares page element area with each image and selects the one that has less mismatching pixels.

h3. Stretching images

When comparing images of different sizes Galen Framework just puts on image on top of another and assumes that the missing pixels are of a black color. But you can change this behavior by stretching the image to fit the original size. Example:

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, error 4%, stretch
$$


h3. Selecting the area in the sample image

You can also define an area which should be used from the sample image like this:

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, error 4%, area 10 10 100 30
$$

The area parameter takes 4 values: left, top, width and height


h3. Offset Analyzer

Sometimes you might have an offset of few pixels on the actual image. That will end up in enormous amount of mismatching pixels. If you want to avoid such situation you can use @analyze-offset@ setting. It takes one integer argument that specifies the maximum size of an offset. Galen will search best fitting offset and will compare images with it.

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, analyze-offset 2
$$

h3. Image filters

Sometimes you might want to apply some filters to compared images to have a smarter image comparison. For instance you can apply blur to images. This might be handy if compared image contains generated noise. Or you can also apply *denoise* filter to the comparison map. That way you get rid of alone mismatching pixels.
Take a look at the following example:

$$ galen-specs
menu-item-1:
    image file item-1.png, error 1%, filter blur 4, filter saturation 0, map-filter denoise 5
$$

What happens with this check is the following: Galen takes both images and applies blur filter with radius 4. Then it applies saturation filter with level 0 which means complete loss of color and the images become gray. Then it compares the image and builds a comparison map. After these operations it applies denoise filter with radius 5 pixels and removes noise from generated map. And after all these operations it counts the mismatching pixels. 

Here is the list of all available image filters:
* *blur <radius>* - Blurs the image with the given radius of blur.
* *saturation <level>* - Removes the colors with the given level. The zero value means complete loss of colors. The 100 value - all the colors are left the same. The level 50 - the image is colored by half.
* *contrast <level>* - Increases the contrast. The allowed range for level is 0 to 258.
* *denoise <radius>* - Removes noise from image. Applicable only as a *map-filter* as it only works with black/white images.
* *quantinize <colorsAmount>* - Makes less colors on the image 


In case you want to apply filter only to original image - you can use @filter-a@ expression like this:

$$ galen-specs
login-button:
    image file imgs/login-button.png, filter-a blur 10, error 4%
$$

You can also use @filter-b@ expression if you need to apply a specific filter to sample image only

$$ galen-specs
login-button:
    image file imgs/login-button.png, filter-b contrast 200, error 4%
$$

Here are some examples of image filters for the original image:

@@
<div class="row">
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Original</h4>
        <img src="/public/filter-examples/original.jpg"/>
    </div>
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Blur level 2</h4>
        <img src="/public/filter-examples/blur-2.png"/>
    </div>
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Blur level 10</h4>
        <img src="/public/filter-examples/blur-10.png"/>
    </div>
</div>
<div class="row">
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Contrast level 100</h4>
        <img src="/public/filter-examples/contrast-100.png"/>
    </div>
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Contrast level 200</h4>
        <img src="/public/filter-examples/contrast-200.png"/>
    </div>
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Saturation level 0</h4>
        <img src="/public/filter-examples/saturation-0.png"/>
    </div>
</div>
<div class="row">
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Saturation level 50</h4>
        <img src="/public/filter-examples/saturation-50.png"/>
    </div>
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Quantinize 2</h4>
        <img src="/public/filter-examples/quantinize-2.png"/>
    </div>
    <div class="col-sm-4 col-lg-4 text-center">
        <h4>Quantinize 10</h4>
        <img src="/public/filter-examples/quantinize-10.png"/>
    </div>
</div>
@@

h3. Cropping

The specification of relative layout sizes (@rem@, @em@ in CSS) can lead to rounding errors in the computed image area sizes, causing areas to seemingly stretch over image borders. The @crop-if-outside@ parameter can be used to force cropping areas to proper image dimensions:

$$ galen-specs
menu-item-1:
    image file imgs/menu-item-1.png, crop-if-outside
$$

If the parameter is left out and an out-of-border area is detected, Galen will report that the specified area is outside the original image.

h1. Advanced Specs

When it comes to testing with Galen you might need to express some more complex specs in your code. In the following paragraphs you can find different ways to make your testing a bit more advanced


h2. Importing

Quite often your website has something similar one each page. Normally it is headers, footers and sometimes the side panel. In case you want to test these for each page you can just import the needed specs. Lets say you have defined specs for header and footer in the following files: @header.gspec@, @footer.gspec@. And now you are working on a @homepage.gspec@ where you would like to import the first two specs. You can do it in the following way

$$ galen-specs
@import header.gspec
@import footer.gspec

# and now goes the spec for your home page
$$

In the example above Galen will import all objects and spec from @header.gspec@ and @footer.gspec@ files and merge them with the @homepage.gspec@. This means that you can then reuse objects from header and footer in your home page spec.


h2. Multiple objects with same specs

So till now you have seen various specs for page objects. But what to do if you want to test exactly the same specs for other objects? In Galen you can use comma separated object notation and simple regex

$$ galen-specs
menu-item-1, menu-item-2, menu-item-3:
    width 100 to 150px
    height 50px
$$

Or same could be written more elegantly

$$ galen-specs
menu-*:
    width 100 to 150px
    height 50px
$$

The example above shows the simplest regular expression. In case you want to match any symbol you can use @*@ symbol. But if you need to match only numbers then you should use @#@ symbol.

$$ galen-specs
menu-item-#:
    width 100px
$$


h2. for Loop

There is also a possibility to declare for loop in case you need to express complex layout for multiple objects. In the following example it will iterate over 9 menu items and will check that each menu item is located from the left side of the following item. 

$$ galen-specs
= Main section =
    @for [1 - 9] as index
        menu-item-${index}:
            left-of menu-item-${index + 1} 10px
$$

As you can see you can declare a variable inside a loop and later use it even in javascript statements.

The @for@ loop statement also allow to declare more complex sequence.

$$ galen-specs
= Main section =
    @for [1 - 5, 7, 9, 14, 20 - 25] as index
        menu-item-${index}:
            left-of menu-item-${index + 1} 10px
$$




h2. forEach Loop

In case you don't want to hard code the numbers and want to match whatever objects you have on the page, you can use @forEach@ loop. It allows to iterate over all objects matching the defined pattern:

$$ galen-specs
= Main section =
    @forEach [menu-item-*] as itemName
        ${itemName}:
            height 30px
$$

But what is more interesting is that you can also define a variable for previous or next item in the loop. 

$$ galen-specs
= Main section =
    @forEach [menu-item-*] as itemName, next as nextItem
        ${itemName}:
            left-of ${nextItem} 10px
$$

That way it will iterate over all elements until last one. If you want to change the statement and reference the previous elements in the loop you can do it like this:

$$ galen-specs
= Main section =
    @forEach [menu-item-*] as itemName, prev as previousItem
        ${itemName}:
            right-of ${previousItem} 10px
$$

That way it will iterate starting from second element in the loop


h2. Custom javascript functions in specs

There is a way to use custom javascript functions inside @${ }@ construction. Lets say you need to put a special function "*i18n*" that would take care of internationalization. You can do it like this:
Create a file @i18n.function.js@:
$$ javascript
this.i18n = function (name) {
    // ...
    // define a code for handling i18n
};
$$

Now you can use it in your specs. Use @script@ in order to load the javascript:

$$ galen-specs
@script i18n.function.js

greeting-text:
    text is "${i18n('header.greeting.text')}"
$$

Same way you can implement a custom function that would allow you to parameterize checks against only even items of a list. Create a script @allEven.js@:
$$ javascript
this.allEven = function (pattern) {
    var size = count(pattern);
    var parameters = "2";
    if (size > 1) {
       for (var i = 4; i <= size; i+=2) {
           parameters = parameters + "," + i;
       }
    }

    return parameters;
};
$$

In spec file call it like this:
$$ galen-specs
@script allEven.js

@for  [${allEven("menu-item-*")}] as index
    menu-item-${index}:
        height 100px
$$




h2. if Statement

It is also possible to declare conditional checks using JavaScript expressions. Lets take a look at the following example. Imagine we have three different banners:

$$ galen-specs
@objects
    banner-1        id  some-banner-1
    banner-2        id  some-banner-2
    banner-3        id  some-banner-3
$$

And now depending on which of the banners is shown on the page we should run specific specs.

$$ galen-specs
#...
= Banners = 
    @if ${isVisible("banner-1")}
        banner-1:
            width 300 px
            height 100 px
    @elseif ${isVisible("banner-2")}
        banner-2:
            width 300 px
            height 100 px
    @else
        banner-3:
            width 300 px
            height 100 px
$$



h2. Warning level for specs

Since version 1.2 it is possible to mark a specific check in your spec file so that once it fails - it is reported with a warning level and does not affect the status of the whole test suite. This might be useful in case you have a bug on your website that you already know and are working on but you don't want to be constantly reminded about it. As a temporary solution you can put @%@ symbol before the failing check and that's it. In the resulting HTML report this check will be shown with yellow color.

$$ galen-specs
login-button:
    text is "Login"
    % width 100px
$$


h2. Custom Rules

Since version 1.6 you can use @rules@ for your specs, which work as sort of a user-defined functions. Custom rules allow you to group complex specs and give them a better naming. Also they allow you to come up with a much more readable spec file. Lets take a simple example. Imagine you want to test that the icon is a square. So you need to test that its width is equal to its height. And for example there could be a lot of other elements on page which should have the same rule. You can write it like this:

$$ galen-specs
@rule %{name} should be squared 
    ${name}:
        width 100% of ${name}/height

# This is how you can use your spec

= Main section =
    | header-icon should be squared
    | footer-icon should be squared
$$

As you can see you can create a mapping to parameters in your rule using @%{...}@ syntax. When you use a rule in your spec with @|@ symbol galen fetches the values from the rule text and provides them in the parameter context. That gives you the possibility to use custom parameters in your specs.


h3. Custom Rules: rules in object context

You can also create rules to serve on an object context. Lets take the above example and change its usage like this:

$$ galen-specs
@rule should be squared
    width 100% of ${objectName}/height

= Main =
    header-icon:
        | should be squared

    footer-icon:
        | should be squared
$$

As you can see we didn't provide any custom parameters but still Galen provides us with @objectName@ parameter. This is possible because the rule is used on an object scope.


h3. Custom Rules: user-defined regular expressions for parameters

By default Galen Framework uses @.*@ regular expression to match the parameter name in rule text. But you can change this behavior by providing custom regex. For example you could have a situation where you need only to match digits

$$ galen-specs
@rule %{object} should be squared with %{size: [0-9]+} pixel size
    ${object}:
        width ${size} px
        height ${size} px

= Main =
    | logo should be squared with 100 pixel size
$$


h3. Custom Rules: JavaScript based rules

If you need to describe a more complex situation you could use JavaScript for rules. Here is an example how to create a JavaScript-based rule that check that the elements are equally distant from each other. You need to define a rule in a separate js file. The rule represents a callback which takes two arguments: *objectName* and *parameters*: 

* *objectName* - represents the name of an object on which the rule was applied. Passed as @null@ in case the rule was applied on a section level without any object.
* *parameters* - represents an object with fields that were defined in the rule text. For instance if you defined a rule with text @located near %{name} with %{distance} pixel margin@ in the end Galen will parse that rule and will provide a structure which you can use as @parameters.name@ and @parameters.distance@

Inside the callback you can create your specs using two functions: *addObjectSpecs* and *addSpecs*  

* *addObjectSpecs(objectName, specs)* - this function should be used in case the rule is applied on section level and on on the object level. It takes the following arguments:
** *objectName* - a name of an object for which the specs should be added.
** *specs* - an array of String. Contains the list of specs which should be added to the specified object
* *addSpecs(specs)* - this function can be used in case a rule is applied on object level. It takes only one argument - array of String, which represents a list of specs that should be added to the object on which the rule was applied.

We can put in @my-rules.js@ file the following:

$$ javascript
rule("%{objectPattern} are equally distant from each other", function (objectName, parameters) {
    // Searching for all objects with user-defined pattern
    var allObjects = findAll(parameters.objectPattern);

    if (allObjects.length > 1) {
        var distance = allObjects[1].left() - allObjects[0].right();
        for (var i = 0; i < allObjects.length - 1; i++) {
            var nextObject = allObjects[i + 1];

            this.addObjectSpecs(allObjects[i].name, [
                "near " + allObjects[i + 1].name + " " + distance + " px left"
            ]);
        }
    } else {
        throw new Error("Not enough objects for pattern: " + parameters.objectPattern);
    }
});
$$

And now if you execute this @my-rules.js@ file in your spec you can use the rule like this:

$$ galen-specs
@script my-rules.js

@objects
    menu-item-*        #menu li a

= Menu =
    | menu-item-* are equally distant from each other
$$


h2. Notes for specs

Sometimes it is hard to understand why a certain validation was chosen in a spec file. Comments could help but what to do with resulting HTML report. You would not be able to see those comments in it. Just for this situation in version 1.6 was introduced a small improvement that allows you to add notes for a specific spec. Just a add a text surrounded with double-quotes before the spec.

$$ galen-specs

header-logo:
    inside header 5 to 15px top, 0 to 10px left
    near header-text 5 to 30px left
    "should be squared" width 100% of header-logo/height
$$

In the resulting report you would get something like this. As you can see on the screenshot, Galen creates a subsection under test object and puts that single spec inside it:

!files/spec-notes.png!


h1. Galen Specs JS Api

In the galen specs you can use JavaScript blocks using @${ ... }@ syntax. In these js blocks you can call the functions from Galen API:

* *count( objectPattern )* - counts the amount of objects matching the given @objectPattern@. 
$$ galen-specs
@for [ 1 - ${count("menu-item-*")} ] as objectName
    ...
    ...
$$

* *find( objectName )* - finds and returns an element with given name. The returned element has the following properties and functions:
** *.left()* - return the left edge position from the left edge of the screen
** *.right()* - return the right edge position from the left edge of the screen
** *.top()* - return the top edge position from the top edge of the screen
** *.bottom()* - return the bottom edge position from the top edge of the screen
** *.width()* - returns the width of the element
** *.height()* - returns the height of the element
** *.isVisible()* - returns true if the element is visible on page, false - if hidden or absent
** *.isPresent()* - returns true if the element is present in the DOM of the page, false - if absent
** *.name* - a name of the element

$$ galen-specs
@set menuMargin  ${find("menu-item-2").left() - find("menu-item-1").right()}
$$

* *isVisible( objectName )* - returns true if the element with given name visible on page, false - if hidden or absent
* *isPresent( objectName )* - returns true if the element with given name present on page, false - if absent
* *findAll( objectPattern )* - returns an array of elements which names match the given pattern.
